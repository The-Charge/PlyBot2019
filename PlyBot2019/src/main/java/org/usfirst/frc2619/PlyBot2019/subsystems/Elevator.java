// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2619.PlyBot2019.subsystems;


import org.usfirst.frc2619.PlyBot2019.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;

import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import edu.wpi.first.wpilibj.Solenoid;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class Elevator extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private WPI_TalonSRX motorStage1;
    private Solenoid brakeStage1;
    private WPI_TalonSRX motorStage2;
    private Solenoid brakeStage2;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    private final static double SPEED_P_CONSTANT_ONE = 1;
	private final static double SPEED_I_CONSTANT_ONE = 0.001;
	private final static double SPEED_D_CONSTANT_ONE = 0.0;
    private final static double SPEED_F_CONSTANT_ONE = 10;
    
    private final static double SPEED_P_CONSTANT_TWO = 1;
	private final static double SPEED_I_CONSTANT_TWO = 0.001;
	private final static double SPEED_D_CONSTANT_TWO = 0.0;
	private final static double SPEED_F_CONSTANT_TWO = 10;
	
    private static final int MAX_TICKS_PER_SEC = 934;
	
	private final static int MOTION_MAGIC_VELOCITY_CONSTANT_ONE = 500;
	private final static int MOTION_MAGIC_ACCELERATION_CONSTANT_ONE = 300;
	private final static double MOTION_MAGIC_P_CONSTANT_ONE = 1;
	private final static double MOTION_MAGIC_I_CONSTANT_ONE = 0.001;
	private final static double MOTION_MAGIC_D_CONSTANT_ONE = 0.0;
    private final static double MOTION_MAGIC_F_CONSTANT_ONE = 10;
    
    private final static int MOTION_MAGIC_VELOCITY_CONSTANT_TWO = 500;
	private final static int MOTION_MAGIC_ACCELERATION_CONSTANT_TWO = 300;
	private final static double MOTION_MAGIC_P_CONSTANT_TWO = 1;
	private final static double MOTION_MAGIC_I_CONSTANT_TWO = 0.001;
	private final static double MOTION_MAGIC_D_CONSTANT_TWO = 0.0;
	private final static double MOTION_MAGIC_F_CONSTANT_TWO = 10;
	
    private static final int TICKS_TO_TOP = 6000;

    final int TIMEOUT_MS = 10;

    public double SpeedPOne = SPEED_P_CONSTANT_ONE;
    public double SpeedIOne = SPEED_I_CONSTANT_ONE;
    public double SpeedDOne = SPEED_D_CONSTANT_ONE;
    public double SpeedFOne = SPEED_F_CONSTANT_ONE;
	
    public double MotionMagicPOne = MOTION_MAGIC_P_CONSTANT_ONE;
    public double MotionMagicIOne = MOTION_MAGIC_I_CONSTANT_ONE;
    public double MotionMagicDOne = MOTION_MAGIC_D_CONSTANT_ONE;
    public double MotionMagicFOne = MOTION_MAGIC_F_CONSTANT_ONE;
    public int MotionMagicVelocityOne = MOTION_MAGIC_VELOCITY_CONSTANT_ONE;
    public int MotionMagicAccelerationOne = MOTION_MAGIC_ACCELERATION_CONSTANT_ONE;
    public double MotionMagicDistanceOne;

    public double SpeedPTwo = SPEED_P_CONSTANT_TWO;
    public double SpeedITwo = SPEED_I_CONSTANT_TWO;
    public double SpeedDTwo = SPEED_D_CONSTANT_TWO;
    public double SpeedFTwo = SPEED_F_CONSTANT_TWO;
	
    public double MotionMagicPTwo = MOTION_MAGIC_P_CONSTANT_TWO;
    public double MotionMagicITwo = MOTION_MAGIC_I_CONSTANT_TWO;
    public double MotionMagicDTwo = MOTION_MAGIC_D_CONSTANT_TWO;
    public double MotionMagicFTwo = MOTION_MAGIC_F_CONSTANT_TWO;
    public int MotionMagicVelocityTwo = MOTION_MAGIC_VELOCITY_CONSTANT_TWO;
    public int MotionMagicAccelerationTwo = MOTION_MAGIC_ACCELERATION_CONSTANT_TWO;
    public double MotionMagicDistanceTwo;

    public boolean movable1 = false;
    public boolean movable2 = false;
    public boolean isUpStage1 = false;
    public boolean isUpStage2 = false;


    public Elevator() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        motorStage1 = new WPI_TalonSRX(9);
        
        
        
        brakeStage1 = new Solenoid(0, 1);
        addChild("BrakeStage1",brakeStage1);
        
        
        motorStage2 = new WPI_TalonSRX(4);
        
        
        
        brakeStage2 = new Solenoid(0, 2);
        addChild("BrakeStage2",brakeStage2);
        
        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop

    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initSpeedPercentageMode1() {
        motorStage1.set(ControlMode.Velocity, 0);
        motorStage1.selectProfileSlot(1, 0);

		motorStage1.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, 0, TIMEOUT_MS);
		if (isUpStage1)
			motorStage1.configClosedloopRamp(0.5, TIMEOUT_MS);
		else
			motorStage1.configClosedloopRamp(1, TIMEOUT_MS);

		motorStage1.configNominalOutputForward(0, TIMEOUT_MS);
		motorStage1.configNominalOutputReverse(0, TIMEOUT_MS);
    }
    
    public void initSpeedPercentageMode2() {
        motorStage2.set(ControlMode.Velocity, 0);
        motorStage2.selectProfileSlot(1,0);

		motorStage2.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, 0, TIMEOUT_MS);
		if (isUpStage2)
			motorStage2.configClosedloopRamp(0.5, TIMEOUT_MS);
		else
			motorStage2.configClosedloopRamp(1, TIMEOUT_MS);

		motorStage2.configNominalOutputForward(0, TIMEOUT_MS);
		motorStage2.configNominalOutputReverse(0, TIMEOUT_MS);
    }
    
	public void stopClosedloopRamp1() {
		motorStage1.configClosedloopRamp(0, TIMEOUT_MS);
	}
    
    public void stopClosedloopRamp2() {
		motorStage2.configClosedloopRamp(0, TIMEOUT_MS);
    }
    
	public void set1(double percentSpeed) {
		if (movable1)
			motorStage1.set(ControlMode.Velocity, MAX_TICKS_PER_SEC * percentSpeed);
    }
    public void set2(double percentSpeed) {
		if (movable2)
			motorStage2.set(ControlMode.Velocity, MAX_TICKS_PER_SEC * percentSpeed);
	}

	public void stop() {
        motorStage1.set(ControlMode.Velocity, 0);
        motorStage2.set(ControlMode.Velocity, 0);
        motorStage1.disable();
        motorStage2.disable();
		brakeOn();
	}
	 
    public void writeDashboardDebugValues() {
    	SmartDashboard.putBoolean("UpperLimitSwitchMotorStage1", motorStage1.getSensorCollection().isFwdLimitSwitchClosed());
        SmartDashboard.putBoolean("LowerLimitSwitchMotorStage1", motorStage1.getSensorCollection().isRevLimitSwitchClosed());
        SmartDashboard.putBoolean("UpperLimitSwitchMotorStage2", motorStage2.getSensorCollection().isFwdLimitSwitchClosed());
        SmartDashboard.putBoolean("LowerLimitSwitchMotorStage2", motorStage2.getSensorCollection().isRevLimitSwitchClosed());
        SmartDashboard.putNumber("ElevatorMMDistance1", MotionMagicDistanceOne);
        SmartDashboard.putNumber("ElevatorMMDistance2", MotionMagicDistanceTwo);
        SmartDashboard.putBoolean("MMFinished1", isAtPIDDestination1());
        SmartDashboard.putBoolean("MMFinished2", isAtPIDDestination2());
    }
    
    public void readDashboardControlValues() {
		SpeedPOne = SmartDashboard.getNumber("ShooterSpeedP1", SPEED_P_CONSTANT_ONE);
		SpeedIOne = SmartDashboard.getNumber("ShooterSpeedI1", SPEED_I_CONSTANT_ONE);
		SpeedDOne = SmartDashboard.getNumber("ShooterSpeedD1", SPEED_D_CONSTANT_ONE);
        SpeedFOne = SmartDashboard.getNumber("ShooterSpeedF1", SPEED_F_CONSTANT_ONE);
        
        SpeedPTwo = SmartDashboard.getNumber("ShooterSpeedP2", SPEED_P_CONSTANT_TWO);
		SpeedITwo = SmartDashboard.getNumber("ShooterSpeedI2", SPEED_I_CONSTANT_TWO);
		SpeedDTwo = SmartDashboard.getNumber("ShooterSpeedD2", SPEED_D_CONSTANT_TWO);
		SpeedFTwo = SmartDashboard.getNumber("ShooterSpeedF2", SPEED_F_CONSTANT_TWO);

		// set CANTalon PIDs
		motorStage1.config_kP(1, SpeedPOne, TIMEOUT_MS);
		motorStage1.config_kI(1, SpeedIOne, TIMEOUT_MS);
		motorStage1.config_kD(1, SpeedDOne, TIMEOUT_MS);
        motorStage1.config_kF(1, SpeedFOne, TIMEOUT_MS);
        
        motorStage2.config_kP(1, SpeedPTwo, TIMEOUT_MS);
		motorStage2.config_kI(1, SpeedITwo, TIMEOUT_MS);
		motorStage2.config_kD(1, SpeedDTwo, TIMEOUT_MS);
		motorStage2.config_kF(1, SpeedFTwo, TIMEOUT_MS);
	}
    
    public void writeDefaultDashboardValues() {
		SmartDashboard.putNumber("ShooterSpeedP1", SPEED_P_CONSTANT_ONE);
		SmartDashboard.putNumber("ShooterSpeedI1", SPEED_I_CONSTANT_ONE);
		SmartDashboard.putNumber("ShooterSpeedD1", SPEED_D_CONSTANT_ONE);
        SmartDashboard.putNumber("ShooterSpeedF1", SPEED_F_CONSTANT_ONE);
        
        SmartDashboard.putNumber("ShooterSpeedP2", SPEED_P_CONSTANT_TWO);
		SmartDashboard.putNumber("ShooterSpeedI2", SPEED_I_CONSTANT_TWO);
		SmartDashboard.putNumber("ShooterSpeedD2", SPEED_D_CONSTANT_TWO);
		SmartDashboard.putNumber("ShooterSpeedF2", SPEED_F_CONSTANT_TWO);
	}

    

    public boolean checkLimitSwitches1() {
    	if (motorStage1.getSensorCollection().isFwdLimitSwitchClosed()) {
    		resetPosBottom();
    		return true;
    	}
    	else if (motorStage1.getSensorCollection().isRevLimitSwitchClosed()) {
    		resetPosTop();
    		return true;
    	}
    	return false;
    }
    
    public boolean checkBottomLimitSwitch1() {
    	if (motorStage1.getSensorCollection().isFwdLimitSwitchClosed()) {
    		resetPosBottom();
    		return true;
    	}
    	return false;
    }
    
    public boolean checkTopLimitSwitch1() {
    	if (motorStage1.getSensorCollection().isRevLimitSwitchClosed()) {
    		resetPosTop();
    		return true;
    	}
    	return false;
    }

    public boolean checkLimitSwitches2() {
    	if (motorStage2.getSensorCollection().isFwdLimitSwitchClosed()) {
    		resetPosBottom();
    		return true;
    	}
    	else if (motorStage2.getSensorCollection().isRevLimitSwitchClosed()) {
    		resetPosTop();
    		return true;
    	}
    	return false;
    }
    
    public boolean checkBottomLimitSwitch2() {
    	if (motorStage2.getSensorCollection().isFwdLimitSwitchClosed()) {
    		resetPosBottom();
    		return true;
    	}
    	return false;
    }
    
    public boolean checkTopLimitSwitch2() {
    	if (motorStage2.getSensorCollection().isRevLimitSwitchClosed()) {
    		resetPosTop();
    		return true;
    	}
    	return false;
    }
    
    public void resetPosTop() {
    	
    }
    
    public void resetPosBottom() {
    	//motor.setSelectedSensorPosition(0, 0, TIMEOUT_MS);
    }
    
    public void brakeOn() {
        brakeStage1.set(false);
        brakeStage2.set(false);
    }
    
    public void brakeOff() {
    	brakeStage1.set(true);
        brakeStage2.set(true);
    }
    
    public void MotionMagicInit1(double percentDistance) {
    	if (movable1) {
	    	MotionMagicDistanceOne = percentDistance;
	    	motorStage1.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, 0, TIMEOUT_MS);
	    	
	    	motorStage1.selectProfileSlot(2,0);
	    	
	    	motorStage1.config_kP(2, MotionMagicPOne, TIMEOUT_MS);
	    	motorStage1.config_kI(2, MotionMagicIOne, TIMEOUT_MS);
	    	motorStage1.config_kD(2, MotionMagicDOne, TIMEOUT_MS);
	    	motorStage1.config_kF(2, MotionMagicFOne, TIMEOUT_MS);
	    	
	    	
	    	motorStage1.configMotionAcceleration(MotionMagicAccelerationOne, TIMEOUT_MS);
	    	motorStage1.configMotionCruiseVelocity(MotionMagicVelocityOne, TIMEOUT_MS);
	    	
	    	MotionMagicDistanceOne *= TICKS_TO_TOP;
	    	motorStage1.set(ControlMode.MotionMagic, MotionMagicDistanceOne);
    	}
    }

    public void MotionMagicInit2(double percentDistance) {
    	if (movable2) {
	    	MotionMagicDistanceTwo = percentDistance;
	    	motorStage2.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, 0, TIMEOUT_MS);
	    	
	    	motorStage2.selectProfileSlot(2,0);
	    	
	    	motorStage2.config_kP(2, MotionMagicPTwo, TIMEOUT_MS);
	    	motorStage2.config_kI(2, MotionMagicITwo, TIMEOUT_MS);
	    	motorStage2.config_kD(2, MotionMagicDTwo, TIMEOUT_MS);
	    	motorStage2.config_kF(2, MotionMagicFTwo, TIMEOUT_MS);
	    	
	    	
	    	motorStage2.configMotionAcceleration(MotionMagicAccelerationTwo, TIMEOUT_MS);
	    	motorStage2.configMotionCruiseVelocity(MotionMagicVelocityTwo,TIMEOUT_MS);
	    	
	    	MotionMagicDistanceTwo *= TICKS_TO_TOP;
	    	motorStage2.set(ControlMode.MotionMagic, MotionMagicDistanceOne);
    	}
    }
    
    public boolean isAtPIDDestination1() {
		return (Math.abs(this.motorStage1.getSelectedSensorPosition(0) - MotionMagicDistanceOne) < 500);// || this.leftFrontMotor.getSelectedSensorPosition(MotionMagicPIDIndex) < -MotionMagicDistance + 6000)
    }
    public boolean isAtPIDDestination2() {
		return (Math.abs(this.motorStage2.getSelectedSensorPosition(0) - MotionMagicDistanceTwo) < 500);// || this.leftFrontMotor.getSelectedSensorPosition(MotionMagicPIDIndex) < -MotionMagicDistance + 6000)
    }
    

}

